1.  What is the purpose of having an individual handler function for each exception/interrupt?
(i.e., if all exceptions/interrupts were delivered to the same handler, what feature that exists
in the current implementation could not be provided?)

If we only had one handler we would not be able to know which exception/interrupts occured.

2. Did you have to do anything to make the user/softint program behave correctly? The grade
script expects it to produce a general protection fault (trap 13), but softint’s code
says int $14. Why should this produce interrupt vector 13? What happens if the kernel
actually allows softint’s int $14 instruction to invoke the kernel’s page fault handler (which
is interrupt vector 14)?

The user is not allowed to generate page faults which is why it gives a protection fault.
If the user were allowed to generate these faults, it could lead to having allocation of pages 
that the process is not authorized to do which could cause security issues.

3. The break point test case will either generate a break point exception or a general
protection fault depending on how you initialized the break point entry in the IDT (i.e., your
call to SETGATE from trap_init). Why? How do you need to set it up in order to get the
breakpoint exception to work as specified above and what incorrect setup would cause it to
trigger a general protection fault?

The reason why it can cause either depends on what the dpl is set to, if it is set to 0 then 
user code cant trigger it causing it to be a general protection fault, but if its set to 3 then
it can be envoked in the user level so the right way is to have the dpl set to 3

4. What do you think is the point of these mechanisms, particularly in light of what
the user/softint test program does?

the purpose of these meachnisms is to be able to protect the kernel.